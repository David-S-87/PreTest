###
## cluster_maker
## A package to simulate clusters of data points.
## J. Foadi - University of Bath - 2024
##
## Module dataframe_builder
###

## Libraries needed
import pandas as pd
import numpy as np

## Function to define the wanted data structure
def define_dataframe_structure(column_specs):
    '''
    Constructs a pandas DataFrame with consistent column lengths based on the provided specifications.
    
    This function takes a list of column specifications, each containing a column name and optional representative points. 
    It ensures all columns have the same length by extending shorter columns with NaN values. 
    The maximum length is determined by the longest list of representative points among the columns.
    
    Parameters:
        column_specs (list of dict): 
            A list where each dictionary represents a column specification with:
            - 'name' (str): The column's name.
            - 'reps' (list, optional): A list of representative points (values) for this column. Defaults to an empty list.
    
    Returns:
        pandas.DataFrame: A DataFrame where each column corresponds to a specification from `column_specs`, 
        with all columns having equal lengths, padded with NaN values as necessary.
    
    Example:
        column_specs = [
            {"name": "A", "reps": [1, 2, 3]},
            {"name": "B", "reps": [4]}
        ]
        
        df = define_dataframe_structure(column_specs)
        # Output:
        #      A    B
        # 0  1.0  4.0
        # 1  2.0  NaN
        # 2  3.0  NaN
    '''

    # Prepare data dictionary
    data = {}
    max_length = 0

    # Find the maximum length of representative points
    for spec in column_specs:
        max_length = max(max_length, len(spec.get('reps', [])))

    for spec in column_specs:
        name = spec['name']
        reps = spec.get('reps', [])
        # Extend numerical columns with NaN to match max_length
        extended_points = reps + [np.nan] * (max_length - len(reps))
        data[name] = extended_points

    return pd.DataFrame(data)

## Function to simulate data
def simulate_data(seed_df, n_points=100, col_specs=None, random_state=None):
    '''
        Simulates new data points based on the values of a seed DataFrame, with column-specific distributions.

    This function generates a specified number of simulated data points for each row of the seed DataFrame. 
    Each simulated point is created by perturbing the corresponding values in the seed DataFrame using specified 
    distributions (e.g., normal, uniform) and variances for each column. The function supports random number 
    generation with a fixed seed for reproducibility.

    Parameters:
        seed_df (pandas.DataFrame): 
            A DataFrame containing the seed data, where each row provides base values for generating simulated points.
        
        n_points (int, optional): 
            The number of simulated points to generate for each row of the `seed_df`. Default is 100.
        
        col_specs (dict, optional): 
            A dictionary where keys are column names and values are dictionaries that specify the distribution 
            ('normal' or 'uniform') and variance for each column. If not provided, no perturbation occurs for a column.
        
        random_state (int, optional): 
            A seed for the random number generator to ensure reproducibility. Default is None (no fixed seed).

    Returns:
        pandas.DataFrame: A DataFrame containing the simulated data points, with the same columns as `seed_df` 
        and `n_points * len(seed_df)` rows, where each simulated point is generated by applying the specified 
        distributions and variances to the corresponding values in `seed_df`.

    Raises:
        ValueError: If a column in `seed_df` does not have a corresponding specification in `col_specs` or if 
        an unsupported distribution type is provided.

    Example:
        seed_df = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})
        col_specs = {
            'A': {'distribution': 'normal', 'variance': 0.5},
            'B': {'distribution': 'uniform', 'variance': 1.0}
        }

        simulated_data = simulate_data(seed_df, n_points=3, col_specs=col_specs, random_state=42)
        print(simulated_data)
        # Output:
        #        A         B
        # 0  1.036  3.374439
        # 1  1.111  4.576978
        # 2  1.478  3.675462
        # 3  2.287  4.327501
        # 4  2.190  4.113526
        # 5  2.282  3.457919
    '''
    if random_state is not None:
        np.random.seed(random_state)
    
    simulated_data = []

    for _, representative in seed_df.iterrows():
        for _ in range(n_points):
            simulated_point = {}
            for col in seed_df.columns:
                # Numerical columns: apply column-specific specifications
                if col_specs and col in col_specs:
                    dist = col_specs[col].get('distribution', 'normal')
                    variance = col_specs[col].get('variance', 1.0)

                    if dist == 'normal':
                        simulated_point[col] = representative[col] + np.random.normal(0, np.sqrt(variance))
                    elif dist == 'uniform':
                        simulated_point[col] = representative[col] + np.random.uniform(-variance, variance)
                    else:
                        raise ValueError(f"Unsupported distribution: {dist}")
                else:
                    raise ValueError(f"Column {col} has no specifications in col_specs.")
            simulated_data.append(simulated_point)
    
    return pd.DataFrame(simulated_data)


def non_globular_cluster(seed_df, n_points=100, col_specs=None, random_state=None):
    if random_state is not None:
        np.random.seed(random_state)
    
    non_globular_data = []
    
    try:
        # Define the pattern for non-globular clusters (e.g., spiral)
        for _ in range(n_points):
            # Example: Generating spiral points for simplicity
            angle = np.random.uniform(0, 2 * np.pi)
            radius = np.random.uniform(0, 1)
            
            x = radius * np.cos(angle)
            y = radius * np.sin(angle)
            
            non_globular_data.append({'A': x, 'B': y})
        
        return pd.DataFrame(non_globular_data)
    except Exception as e:
        print(f"An error occurred while generating non-globular clusters: {e}")
        return pd.DataFrame()